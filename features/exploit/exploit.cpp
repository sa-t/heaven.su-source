#include "../exploit/exploit.h"
#include "../lagcompensation/animation_system.h"
#include "../ragebot/aim.h"
#include "..\misc\prediction_system.h"

bool can_shift_shot(int ticks)
{
	if (!g_ctx.local() || !g_ctx.local()->m_hActiveWeapon())
		return false;

	auto tickbase = g_ctx.local()->m_nTickBase();
	auto curtime = m_globals()->m_intervalpertick * (tickbase - ticks);

	if (curtime < g_ctx.local()->m_flNextAttack())
		return false;

	if (curtime < g_ctx.local()->m_hActiveWeapon()->m_flNextPrimaryAttack())
		return false;

	return true;
}

bool exploit::defensive(CUserCmd* m_pcmd)
{
	if (!g_ctx.globals.weapon->can_fire(true))
		return false;
	if (antiaim::get().freeze_check)
		return false;

	auto max_tickbase_shift = g_ctx.globals.weapon->get_max_tickbase_shift();
	auto velocity = engineprediction::get().backup_data.velocity.Length();
	auto choked = m_clientstate()->iChokedCommands;
	static auto switch_ticks = false;
	static auto shift_peek_ticks = 0;

	static auto last_double_tap = 0;


	if (g_cfg.ragebot.double_tap && g_cfg.ragebot.double_tap_key.key > KEY_NONE && g_cfg.ragebot.double_tap_key.key < KEY_MAX && exploit::get().double_tap_key)
	{
		if (g_cfg.ragebot.enable && g_ctx.globals.current_weapon != -1 && !g_ctx.globals.m_Peek.started_peeking_Defensive && velocity >= 5.0f)
		{
			auto predicted_eye_pos = g_ctx.globals.eye_pos + engineprediction::get().backup_data.velocity * m_globals()->m_intervalpertick * (float)24.0f;

			for (auto i = 1; i < m_globals()->m_maxclients; i++)
			{
				auto e = static_cast<player_t*>(m_entitylist()->GetClientEntity(i));

				if (!e->valid(true))
					continue;

				auto records = &player_records[i];

				if (records->empty())
					continue;

				auto record = &records->front();

				if (!record->valid())
					continue;

				scan_data predicted_data;
				aim::get().scan(record, predicted_data, predicted_eye_pos);

				if (predicted_data.valid())
				{
					scan_data data;
					aim::get().scan(record, data, g_ctx.globals.eye_pos);

					if (!data.valid())
					{
						shift_peek_ticks = 14;
						g_ctx.globals.m_Peek.started_peeking_Defensive = true;

						g_ctx.send_packet = true;
					}
				}
			}
		}
		if (g_ctx.globals.m_Peek.started_peeking_Defensive)
		{
			++shift_peek_ticks;
			if (shift_peek_ticks > 14)
			{
				(g_ctx.globals.m_Peek.started_peeking_Defensive = false);
			}
		}
		else
		{
			shift_peek_ticks = 0;
		}

		g_ctx.globals.tickbase_shift = shift_peek_ticks;
		return true;
	}
	else
	{
		g_ctx.globals.m_Peek.started_peeking_Defensive = false;
	}
}


bool exploit::double_tap(CUserCmd* m_pcmd)
{
	static float lastdoubletaptime = 0.0f;
	if (!g_cfg.ragebot.double_tap || (g_cfg.ragebot.double_tap_key.key <= KEY_NONE || g_cfg.ragebot.double_tap_key.key >= KEY_MAX) || !g_cfg.ragebot.double_tap_key.key || !double_tap_key)
	{
		g_ctx.globals.double_tap_aim = false;
		g_ctx.globals.double_tap_aim_check = false;
		g_ctx.globals.shift_ticks = g_ctx.globals.tocharge;
		return false;
	}
	auto weapon = g_ctx.local()->m_hActiveWeapon();
	if (!(m_pcmd->m_buttons & IN_ATTACK) && g_ctx.globals.tocharge < 14 && abs(g_ctx.globals.fixed_tickbase - lastdoubletaptime) >= TIME_TO_TICKS(0.6)) {
		this->double_tap_enabled = false;
		g_ctx.globals.should_recharge = true;
		g_ctx.globals.tochargeamount = 14;
	}
	else {
		this->double_tap_enabled = true;
		g_ctx.globals.should_recharge = false;
	}

	if (g_ctx.globals.tocharge > 14) {
		g_ctx.globals.shift_ticks = g_ctx.globals.tocharge - 14;
	}

	if (weapon && (m_pcmd->m_buttons & IN_ATTACK || (m_pcmd->m_buttons & IN_ATTACK2 && weapon->is_knife())) && g_ctx.globals.tocharge >= 14) {
		lastdoubletaptime = g_ctx.globals.fixed_tickbase;

		g_ctx.globals.tickbase_shift = 14;
		g_ctx.globals.shift_ticks = 14;
		g_ctx.globals.shot_command = g_ctx.get_command()->m_command_number;
		defensive(m_pcmd);
	}

	if (g_ctx.globals.aimbot_working)
	{
		g_ctx.globals.double_tap_aim = true;
		g_ctx.globals.double_tap_aim_check = true;
	}
	if (g_ctx.globals.tickbase_shift <= 0)
		g_ctx.globals.tickbase_shift = g_ctx.globals.shift_ticks;
	return true;
}

void exploit::hide_shots(CUserCmd* m_pcmd, bool should_work)
{
	hide_shots_enabled = true;

	if (!g_cfg.ragebot.enable)
	{
		hide_shots_enabled = false;
		hide_shots_key = false;

		if (should_work)
		{
			g_ctx.globals.ticks_allowed = 0;
			g_ctx.globals.next_tickbase_shift = 0;
		}

		return;
	}

	if (!g_cfg.antiaim.hide_shots)
	{
		hide_shots_enabled = false;
		hide_shots_key = false;

		if (should_work)
		{
			g_ctx.globals.ticks_allowed = 0;
			g_ctx.globals.next_tickbase_shift = 0;
		}

		return;
	}

	if (g_cfg.antiaim.hide_shots_key.key <= KEY_NONE || g_cfg.antiaim.hide_shots_key.key >= KEY_MAX)
	{
		hide_shots_enabled = false;
		hide_shots_key = false;

		if (should_work)
		{
			g_ctx.globals.ticks_allowed = 0;
			g_ctx.globals.next_tickbase_shift = 0;
		}

		return;
	}

	if (!should_work && double_tap_key)
	{
		hide_shots_enabled = false;
		hide_shots_key = false;
		return;
	}

	if (!hide_shots_key)
	{
		hide_shots_enabled = false;
		g_ctx.globals.ticks_allowed = 0;
		g_ctx.globals.next_tickbase_shift = 0;
		return;
	}

	double_tap_key = false;

	if (g_ctx.local()->m_bGunGameImmunity() || g_ctx.local()->m_fFlags() & FL_FROZEN)
	{
		hide_shots_enabled = false;
		g_ctx.globals.ticks_allowed = 0;
		g_ctx.globals.next_tickbase_shift = 0;
		return;
	}

	if (g_ctx.globals.fakeducking)
	{
		hide_shots_enabled = false;
		g_ctx.globals.ticks_allowed = 0;
		g_ctx.globals.next_tickbase_shift = 0;
		return;
	}

	if (antiaim::get().freeze_check)
		return;

	g_ctx.globals.next_tickbase_shift = m_gamerules()->m_bIsValveDS() ? 6 : 9;

	auto revolver_shoot = g_ctx.globals.weapon->m_iItemDefinitionIndex() == WEAPON_REVOLVER && !g_ctx.globals.revolver_working && (m_pcmd->m_buttons & IN_ATTACK || m_pcmd->m_buttons & IN_ATTACK2);
	auto weapon_shoot = m_pcmd->m_buttons & IN_ATTACK && g_ctx.globals.weapon->m_iItemDefinitionIndex() != WEAPON_REVOLVER || m_pcmd->m_buttons & IN_ATTACK2 && g_ctx.globals.weapon->is_knife() || revolver_shoot;

	if (g_ctx.send_packet && !g_ctx.globals.weapon->is_grenade() && weapon_shoot)
		g_ctx.globals.tickbase_shift = g_ctx.globals.next_tickbase_shift;
}